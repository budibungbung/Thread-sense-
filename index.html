<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b1020" />
  <title>Thread Sense</title>
  <link rel="manifest" href="manifest.json" />
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b1020; overflow:hidden; touch-action:manipulation; }
    canvas { width:100vw; height:100vh; display:block; }

    .hud{ position:fixed; inset:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#eaf0ff; }
    .top{
      position:absolute; top: env(safe-area-inset-top, 0px); left:0; right:0;
      display:flex; justify-content:space-between; gap:10px; padding:14px 16px;
      pointer-events:none; font-weight:800;
    }
    .pill{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      padding:8px 10px; border-radius:999px;
      backdrop-filter: blur(8px);
      display:flex; gap:8px; align-items:center;
      max-width: 48vw; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;
    }

    .center{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      padding:24px; text-align:center;
    }
    .card{
      max-width: 680px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 16px 16px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      pointer-events:auto;
    }
    .title{ font-size: 22px; margin:0 0 8px; }
    .muted{ opacity:.86; line-height:1.35; margin:0 0 12px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
    button{
      appearance:none; border:0;
      padding:12px 14px; border-radius:12px;
      font-weight:900; cursor:pointer;
    }
    button.primary{ background:#2d6cff; color:white; box-shadow: 0 10px 20px rgba(45,108,255,.25); }
    button.secondary{
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
      color:#eaf0ff;
    }
    #installBtn{ display:none; }
    .hint{ font-size:12px; opacity:.78; margin-top:10px; }

    .answers{
      position:absolute; left:0; right:0; bottom: env(safe-area-inset-bottom, 0px);
      padding: 12px 14px 14px;
      display:flex; gap:12px; justify-content:center;
      pointer-events:auto;
    }
    .answers button{ min-width: 150px; }

    .toast{
      position:absolute; left:50%; transform:translateX(-50%);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 92px);
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 900;
      opacity:0; transition:opacity .18s ease;
      pointer-events:none;
    }
    .toast.show{ opacity:1; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="top">
      <div class="pill">Score: <span id="score">0</span> · Streak: <span id="streak">0</span></div>
      <div class="pill">Best streak: <span id="best">0</span></div>
    </div>

    <div class="center" id="menu">
      <div class="card">
        <h1 class="title">Thread Sense</h1>
        <p class="muted">
          First-person view: you’re standing in front of the bolt.<br>
          The wrench handle position is shown (like a clock).<br><br>
          Answer using <b><span id="styleLabel">PUSH / PULL</span></b>.
        </p>
        <div class="row">
          <button id="startBtn" class="primary">Start</button>
          <button id="installBtn" class="secondary">Install to Home Screen</button>
          <button id="goalBtn" class="secondary">Goal: Loosen</button>
          <button id="styleBtn" class="secondary">Answer style: Push/Pull</button>
        </div>
        <div class="hint" id="installHint">iPhone/iPad: Share → Add to Home Screen</div>
        <div class="hint" style="opacity:.7">
          Mostly <b>right-hand</b> threads, sometimes <b>left-hand</b>.
        </div>
      </div>
    </div>

    <div class="answers" id="answers" style="display:none">
      <button id="aBtn" class="secondary">PUSH</button>
      <button id="bBtn" class="secondary">PULL</button>
    </div>

    <div class="toast" id="toast">Nice</div>
  </div>

<script>
(() => {
  // PWA install prompt (Android/Chromium)
  let deferredPrompt = null;
  const installBtn = document.getElementById('installBtn');
  const installHint = document.getElementById('installHint');
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    installBtn.style.display = 'inline-block';
    installHint.style.display = 'none';
  });
  installBtn.addEventListener('click', async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    await deferredPrompt.userChoice;
    deferredPrompt = null;
    installBtn.style.display = 'none';
  });
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js'));
  }

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const menu = document.getElementById('menu');
  const answers = document.getElementById('answers');
  const startBtn = document.getElementById('startBtn');
  const goalBtn = document.getElementById('goalBtn');
  const styleBtn = document.getElementById('styleBtn');

  const aBtn = document.getElementById('aBtn');
  const bBtn = document.getElementById('bBtn');

  const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const bestEl = document.getElementById('best');
  const toast = document.getElementById('toast');
  const styleLabel = document.getElementById('styleLabel');

  const state = {
    running:false,
    w:0,h:0,dpr:1,
    score:0, streak:0,
    best: Number(localStorage.getItem('thread_sense_best2') || 0),
    goal:'loosen',           // loosen/tighten
    answerStyle:'pushpull',  // pushpull or leftright
    // question vars
    handlePos: 0,            // 0=top,1=right,2=bottom,3=left (clock positions)
    thread: 'RH',            // RH/LH
    correctDir: null,        // direction of motion at handle end: up/right/down/left (0..3)
    correctAnswer: null      // "push"/"pull" OR "left"/"right"
  };
  bestEl.textContent = state.best;

  function resize(){
    state.dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    state.w = Math.floor(window.innerWidth  * state.dpr);
    state.h = Math.floor(window.innerHeight * state.dpr);
    canvas.width = state.w;
    canvas.height = state.h;
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // prevent double tap zoom
  let lastTap = 0;
  window.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 350) e.preventDefault();
    lastTap = now;
  }, { passive:false });

  goalBtn.addEventListener('click', () => {
    state.goal = (state.goal === 'loosen') ? 'tighten' : 'loosen';
    goalBtn.textContent = `Goal: ${cap(state.goal)}`;
  });

  styleBtn.addEventListener('click', () => {
    state.answerStyle = (state.answerStyle === 'pushpull') ? 'leftright' : 'pushpull';
    if (state.answerStyle === 'pushpull'){
      aBtn.textContent = 'PUSH';
      bBtn.textContent = 'PULL';
      styleBtn.textContent = 'Answer style: Push/Pull';
      styleLabel.textContent = 'PUSH / PULL';
    } else {
      aBtn.textContent = 'LEFT';
      bBtn.textContent = 'RIGHT';
      styleBtn.textContent = 'Answer style: Left/Right';
      styleLabel.textContent = 'LEFT / RIGHT';
    }
    if (state.running) nextQuestion();
  });

  startBtn.addEventListener('click', start);
  aBtn.addEventListener('click', () => answer(state.answerStyle === 'pushpull' ? 'push' : 'left'));
  bBtn.addEventListener('click', () => answer(state.answerStyle === 'pushpull' ? 'pull' : 'right'));

  // one-thumb: tap left/right half = left/right OR push/pull (same buttons)
  canvas.addEventListener('pointerdown', (e) => {
    if (!state.running) return;
    const isLeft = e.clientX < window.innerWidth/2;
    if (state.answerStyle === 'pushpull') answer(isLeft ? 'push' : 'pull');
    else answer(isLeft ? 'left' : 'right');
  }, { passive:true });

  function start(){
    state.running = true;
    state.score = 0; state.streak = 0;
    scoreEl.textContent = '0';
    streakEl.textContent = '0';
    menu.style.display = 'none';
    answers.style.display = 'flex';
    nextQuestion();
    requestAnimationFrame(loop);
  }

  function nextQuestion(){
    // handle position around bolt (clock positions)
    // keep it simple & unambiguous: top/right/bottom/left
    state.handlePos = Math.floor(Math.random() * 4);

    // threads: mostly RH
    state.thread = (Math.random() < 0.15) ? 'LH' : 'RH';

    // determine desired rotation from YOUR POV looking at the bolt
    // CCW = loosen for RH, tighten for LH
    const desiredRot =
      (state.thread === 'RH')
        ? (state.goal === 'loosen' ? +1 : -1)
        : (state.goal === 'loosen' ? -1 : +1);

    // Map handle position -> required motion direction at handle end (tangent)
    // Positions (your POV):
    //   0 top    -> CCW needs LEFT,  CW needs RIGHT
    //   1 right  -> CCW needs UP,    CW needs DOWN
    //   2 bottom -> CCW needs RIGHT, CW needs LEFT
    //   3 left   -> CCW needs DOWN,  CW needs UP
    const CCW_dir = [3, 0, 1, 2]; // top->left(3), right->up(0), bottom->right(1), left->down(2)
    const CW_dir  = [1, 2, 3, 0]; // top->right(1), right->down(2), bottom->left(3), left->up(0)
    state.correctDir = (desiredRot > 0) ? CCW_dir[state.handlePos] : CW_dir[state.handlePos];

    // Convert required direction into answer style:
    // - For Left/Right: answer is LEFT or RIGHT when dir is left/right; if dir is up/down we map to LEFT/RIGHT using a simple rule:
    //   LEFT = "move handle end left or up", RIGHT = "move handle end right or down" (consistent training cue).
    // - For Push/Pull: PUSH = move handle end "away from you" (up on screen), PULL = toward you (down on screen).
    //   (This matches the common “standing in front of it” perspective.)
    if (state.answerStyle === 'leftright'){
      state.correctAnswer = (state.correctDir === 3 || state.correctDir === 0) ? 'left' : 'right';
    } else {
      state.correctAnswer = (state.correctDir === 0 || state.correctDir === 3) ? 'push' : 'pull';
    }
  }

  function answer(choice){
    if (!state.running) return;
    const ok = (choice === state.correctAnswer);

    if (ok){
      state.score += 1;
      state.streak += 1;
      scoreEl.textContent = String(state.score);
      streakEl.textContent = String(state.streak);
      showToast('✅ Correct', true);
    } else {
      state.streak = 0;
      streakEl.textContent = '0';
      showToast(`❌ Wrong (${state.correctAnswer.toUpperCase()})`, false);
    }

    if (state.streak > state.best){
      state.best = state.streak;
      localStorage.setItem('thread_sense_best2', String(state.best));
      bestEl.textContent = state.best;
    }

    setTimeout(() => nextQuestion(), 420);
  }

  let toastTimer = null;
  function showToast(text, good){
    toast.textContent = text;
    toast.classList.add('show');
    toast.style.borderColor = good ? 'rgba(32,201,151,.35)' : 'rgba(255,77,109,.35)';
    if (toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove('show'), 650);
  }

  function loop(){
    if (!state.running) return;
    render();
    requestAnimationFrame(loop);
  }

  function render(){
    ctx.fillStyle = '#0b1020';
    ctx.fillRect(0,0,state.w,state.h);

    // Draw a "wall/plate" to make it feel first-person
    const plateW = state.w * 0.86;
    const plateH = state.h * 0.62;
    const px = (state.w - plateW)/2;
    const py = state.h*0.16;
    ctx.fillStyle = 'rgba(255,255,255,.05)';
    roundRect(px, py, plateW, plateH, 22*state.dpr);
    ctx.fill();

    // YOU marker at bottom (your POV anchor)
    ctx.fillStyle = 'rgba(255,255,255,.12)';
    roundRect(state.w*0.5 - 90*state.dpr, state.h*0.86, 180*state.dpr, 46*state.dpr, 18*state.dpr);
    ctx.fill();
    ctx.fillStyle = 'rgba(234,240,255,.85)';
    ctx.font = `${Math.floor(14*state.dpr)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('YOU (standing here)', state.w*0.5, state.h*0.86 + 23*state.dpr);

    // Bolt center on the plate
    const cx = state.w * 0.5;
    const cy = state.h * 0.47;
    const boltR = 52 * state.dpr;

    // Instruction text (your POV)
    ctx.fillStyle = 'rgba(234,240,255,.90)';
    ctx.font = `${Math.floor(18*state.dpr)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(`GOAL: ${state.goal.toUpperCase()}  •  THREAD: ${state.thread === 'RH' ? 'RIGHT-HAND' : 'LEFT-HAND'}`, cx, state.h*0.10);
    ctx.globalAlpha = 0.82;
    ctx.font = `${Math.floor(14*state.dpr)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(`Handle position shown like a clock. Answer: ${state.answerStyle === 'pushpull' ? 'PUSH/PULL' : 'LEFT/RIGHT'}`, cx, state.h*0.135);
    ctx.globalAlpha = 1;

    // Bolt face
    ctx.fillStyle = 'rgba(255,255,255,.10)';
    circle(cx, cy, boltR); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,.06)';
    circle(cx, cy, boltR*0.78); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,.11)';
    hex(cx, cy, boltR*0.46); ctx.fill();

    // Wrench handle positions around bolt (top/right/bottom/left)
    const handleLen = 240 * state.dpr;
    const handleW = 28 * state.dpr;

    const posVec = [
      {x:0, y:-1}, // top
      {x:1, y:0},  // right
      {x:0, y:1},  // bottom
      {x:-1,y:0}   // left
    ][state.handlePos];

    // Jaw point on bolt edge
    const jx = cx + posVec.x * boltR * 0.95;
    const jy = cy + posVec.y * boltR * 0.95;

    // Handle extends outward from that point
    const ex = cx + posVec.x * (boltR + handleLen);
    const ey = cy + posVec.y * (boltR + handleLen);

    // Draw jaw (shows spanner location clearly)
    ctx.fillStyle = 'rgba(255,255,255,.16)';
    roundRect(jx - 26*state.dpr, jy - 18*state.dpr, 52*state.dpr, 36*state.dpr, 10*state.dpr);
    ctx.fill();

    // Handle
    ctx.fillStyle = 'rgba(45,108,255,.95)';
    capsule(jx, jy, ex, ey, handleW);
    ctx.fill();

    // Hand/grip end marker
    ctx.fillStyle = 'rgba(255,255,255,.18)';
    circle(ex, ey, handleW*0.90); ctx.fill();

    // Clock label (TOP/RIGHT/BOTTOM/LEFT)
    const labels = ['TOP', 'RIGHT', 'BOTTOM', 'LEFT'];
    ctx.fillStyle = 'rgba(234,240,255,.80)';
    ctx.font = `${Math.floor(13*state.dpr)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(`HANDLE: ${labels[state.handlePos]}`, cx, cy + boltR*1.85);

    // Small directional hint arrow (NOT the answer style, just shows required motion direction)
    // This is the “why” – helps you learn faster.
    drawDirArrow(ex, ey, state.correctDir);
  }

  // Helpers
  function cap(s){ return s.charAt(0).toUpperCase() + s.slice(1); }
  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.closePath(); }
  function hex(x,y,r){
    ctx.beginPath();
    for (let i=0;i<6;i++){
      const a = (Math.PI/3)*i + Math.PI/6;
      const px = x + Math.cos(a)*r;
      const py = y + Math.sin(a)*r;
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
  }
  function roundRect(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }
  function capsule(x1,y1,x2,y2,thick){
    const dx=x2-x1, dy=y2-y1;
    const len=Math.hypot(dx,dy) || 1;
    const ux=dx/len, uy=dy/len;
    const px=-uy, py=ux;
    const r=thick/2;
    ctx.beginPath();
    ctx.moveTo(x1 + px*r, y1 + py*r);
    ctx.lineTo(x2 + px*r, y2 + py*r);
    ctx.arc(x2, y2, r, Math.atan2(py,px), Math.atan2(-py,-px), false);
    ctx.lineTo(x1 - px*r, y1 - py*r);
    ctx.arc(x1, y1, r, Math.atan2(-py,-px), Math.atan2(py,px), false);
    ctx.closePath();
  }

  // dir: 0 up, 1 right, 2 down, 3 left
  function drawDirArrow(x,y,dir){
    const L = 44 * state.dpr;
    const ax = [0, 1, 0, -1][dir];
    const ay = [-1,0, 1,  0][dir];
    const x2 = x + ax*L, y2 = y + ay*L;

    ctx.strokeStyle = 'rgba(255,255,255,.24)';
    ctx.lineWidth = 6 * state.dpr;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    ctx.fillStyle = 'rgba(255,255,255,.24)';
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - ax*16*state.dpr + (-ay)*10*state.dpr, y2 - ay*16*state.dpr + (ax)*10*state.dpr);
    ctx.lineTo(x2 - ax*16*state.dpr + (ay)*10*state.dpr,  y2 - ay*16*state.dpr + (-ax)*10*state.dpr);
    ctx.closePath();
    ctx.fill();
  }
})();
</script>
</body>
</html>